代码复用的心得:
	不要只用集体类写程序，要利用抽象类和接口才对！

1.Iterator pattern
	依次遍历并处理多个数字或变量。
   包括:取得迭代的接口、迭代接口、迭代的具体使用者、具体的迭代器、还有需要迭代的对象。

2.Adapter pattern
	如果既有内容无法直接利用时，通常需要先转换成必要的类型后再使用。
  
  分类:
	当转换的目标为接口时，称作适配。当转换目标为类时，称作委托。
	适配:是用接口的方法调用既有的资源。
	委托:是用Adapter的字段来调用目标方法进而封装这些方法。
  
  用途:因为它是修改现有资源去适应新的需求所以一般在版本更新或类得重用上使用。


3.Template Method Pattern p55
	父类指定处理大纲、在子类规定具体内容的Design Pattern。且父类的处理大纲中用到的方法都是抽象方法。
  作用:这样在需要修改程序算法的时候只修改父类的骨架就可以了，不必依次修改每个子类。

4.Factotry Method Pattern p67
	把Template Method Pattern的父类逻辑大纲骨架如果应用在产生对象实例方面，就是Factory Method Pattern。
  包含:工厂的抽象类和产品的抽象类，以及他们的具体实现。

5.Singleton Pattern
	一个private的构造函数，一个getInStance方法来得到实例，同时还要有一个初始化方法在加载类时建立一个实例。

6.Prototype Pattern原形模式
实现:
	定义一个接口继承Cloneable类，在其中定义方法分别是该对象将被如何使用以及克隆该对象，当然都还没有实现。定义具体的类实现上面的接口，定义一个manager类来统一管理注册，其实就是把注册的对象放入一个Hashtable，并且实现第一个接口。

使用情况:
	种类过多无法整合成类
	不容易利用类产生对象实例(图形)
	希望把框架何所产生的对象实例分开时

7.Builder Pattern生成器模式
	循序渐进的组合较复杂的对象实例。
	有一个Builder的抽象类来规定执行的方法，由子类来具体实现，由Director来决定Builder的调用过程，客户cilent类只需要调用Director类即可。

8.Abstract Factory pattern(抽象工厂)p113
	组成:
		一个抽象的Factory类，里面定义所要产生的抽象零件和产品。以及取得工厂子实例的方法。
		所有要用到的零件抽象类，有包含关系同样放入集合类中。并且为了让整个主类与具体的实现类相脱离，可以为这些零件特意抽象出一个父类，调用方法就直接使用这个抽象类来调用。因为结构是通过抽象类来实现的，所以集合类以及嵌套的关系由抽象类维护，只有集体实现交由实现类。
		剩下的具体类的方法都由抽象类所规定好了，实现就可以了。

	优点:新增具体工厂容易，只要实现所有的抽象类就可以了。
	缺点:新增零件困难，要修改抽象父类，以及所有的具体实现了的具体子类。
	

9.Bridge parttern(侨接模式)p136
	功能的类层次:基本功能放到父类、新增功能放到子类。
	实现的类层次:父类使用抽象方法来规定接口，子类使用具体方法来实现此接口。

	何时使用这种模式，因为继承是一种固态的类关系，当想要改变这种关系时必须修改源代码。而如果使用委托这种关系，就可以在使用类时动态的定义哪种实现与当前的功能类配合使用，方便对不同情况的分别适应。

	模式原理:整体来说就是使用委托来作为功能类层次和实现类层次之间的连接，功能类层次的顶层类存储了实现类层次的顶层类的对象，并且在每个方法中都是通过该对象的方法来实现。从而达到两边类层次的任意匹配。

	p145
	答案p391