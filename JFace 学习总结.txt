1.运行包含swt组件的工程时要额外加入的包以及对应类的情况:
	org.eclipse.equinox.common包中的IProgressMonitor的一个接口。
	org.eclipse.core.commands包中的EventManager的一个抽象类。
ContentProvider和LabelProvider分别控制查看器中显示的哪些数据以及每条数据的显示方式

createContents(Composite parent)函数

	在jface的window中，当用户继承了window的某个子类后，内容窗格的所有东西都要在这个函数中重载定义。图在我的文档的一张IBM的网页中。

2.ILabelProvider或LabelProvider
	
	实现或继承以上的两个类中定制的程序就可以改变要显示内容的样式，如名字、图像等等。同时也要在使用这种方法的对象中通过setLabelProvider方法把该类的对象作为参数传入进去。


3.TreeView
	TreeView不是像ApplicationWindow那样通过子类来实现的，但它的实现一样少不了一种内容支持它就是ITreeContentProvider，这是一个接口，在其中我们要实现getChildren、getElement等等这样的与展开树中某个节点有关的函数，而实现了这个接口的类的对象要作为TreeView的参数传入。并且，需要注意一点的是TreeView不是一个窗口构件，所以当从CreateContents返回时要返回它的getTree()方法所返回的值。

4.实现动态的向导页
	继承了WizardPage的类，其自己的createControl方法参数parent是其整个向导的控件我们必须新建自己的组件(Composite),并且需要把这个组件通过setControl()方法传给整个对话框，否则在初始化这个向导时不能正常显示。因为向导对话框中每个向导页都是同时被初始化的。也因为上面的原因，所以要实现动态的向导不能仅仅在各个向导页中的createControl方法中作改变。每个向导页在显示之前都要调用setVisible方法，我们可以在这里添加数据或建立界面，这样在每次显示该页时就会有动态效果了！

5.JFace事件处理
	包括Action、ContributeManager和ContributionItem三个基本的概念。在ToolBarManager中继承的是ContributionManager类，而且不论是它的实现还是继承最终都落在IContributionManager接口上。而在ToolManager中的add()方用的也都是IContributionManager的方法，当添加一个Action时会将它转换成IContributionManager然后再把加入到这个贡献加入到一个List列表中。实际上ToolBarManager就在其中加了ToolBar这么一个组件用来显示给用户。
	而在MenuManager中，多添加了一个ContributeItem的概念，所以这就比上面的ToolBarManager复杂多了。即它同时身兼两职，当它作为item时主要是与SWT的组件有关，为了把自己加到swt组件中，可以叫做找父其。当它作为Manager时主要是与JFace的IAction或者IContributionItem交互，来添加自己的孩子。

6.treeViewer的设计
	因为涉及到对于树的打开状态的保存，所以在设计一颗树的model的时候，务必考虑到如何通过路径来找到某个树结点，否则就要使其实现Serializable这个接口才能使存储的元素与树中元素相对应。