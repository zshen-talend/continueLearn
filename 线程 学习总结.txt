SWT中的线程
	Thread thread=new Thread();
		public void run(){
			Display.getDefault().syncExec(new Runnable(){
	public void run(){
		....
	}
			....
		}
	thread.start();

解决界面连续操作的闪屏问题
	使用线程来刷新界面，并且让该线程延迟执行，最后在界面刷新以后把线程置空，这样后续的几个线程就不会执行了！


定时执行
	Display.getCurrent().timerExec(1000, runnable);


java篇
1.java取得当前的线程
	Thread.currentThread()

2.并发(concurrent):在同一时刻只有一个执行，但之间会交替执行。

3.并行(parallel):在同一时刻两者同时执行。

4.Thread类
	开始一个线程start()
	让当前线程等待某个线程结束再运行。join()

	1) sleep() 方法：sleep() 允许指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。

	2) suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。

　	3) yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。

	4) wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。

　　初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。
	
	守护线程和非守护线程
	守护线程一般用来在后台为其它线程提供服务，应用程序的所有非守护线程都结束了，不管是否还有守护线程在运行，应用程序都将关闭。否则只要有非守护线程在运行，应用就不会结束。可以使用idDeamon和setDeamon方法来判断和设置线程是否是守护线程。

	线程组

	线程组是一个 Java 特有的概念，在 Java 中，线程组是类ThreadGroup 的对象，每个线程都隶属于唯一一个线程组，这个线程组在线程创建时指定并在线程的整个生命期内都不能更改。
	你可以通过调用包含 ThreadGroup 类型参数的 Thread 类构造函数来指定线程属的线程组，若没有指定，则线程缺省地隶属于名为 system 的系统线程组。
	
	在 Java 中，除了预建的系统线程组外，所有线程组都必须显式创建。在 Java 中，除系统线程组外的每个线程组又隶属于另一个线程组，你可以在创建线程组时指定其所隶属的线程组，若没有指定，则缺省地隶属于系统线程组。这样，所有线程组组成了一棵以系统线程组为根的树。

